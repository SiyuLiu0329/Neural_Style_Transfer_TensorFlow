import tensorflow as tf
import numpy as np
import scipy.misc
from vgg_model import Model
from utilities import load_image



class NSTModel:
    """Neural Style Transfer Model.
    Constructs a computational graph and runs it to generate art images.

    Attributes:
        self.STYLE_LAYERS: List of layers from which the style features will be extracted.
        self._content_img: Loaded content image stored in a numpy array of shape (1, height, width, 3).
        self._style_img: Loaded content image stored in a numpy array of shape (1, height, width, 3).
        self._initial_image: The starting image. Can be an existing image or a newly initialised image.
        self._sess: A tf session used to compute features and generate images.
        self._vgg: A pre-loaded vgg model defined in model `vgg_model`.
        self._out: The output node of the vgg model.
        self._content_features: Content features of the output layer of the vgg model.
        self._style_features: List of style computed features from layers in `self.STYLE_LAYERS`.
    """

    def __init__(self, output_layer='conv5_2', h=300, w=400, style_path=None, content_path=None, input_image_path=None, 
                 style_weights=[0.5, 1.0, 2.1, 3.2, 4.0]):
        """inits the model.
        Args:
            put_layer (str): layer to use when computing content loss.
            h (int): height of image.
            w (int): width of image.
            style_path (str): path of the style image.
            content_path (str): path of the content image.
            input_image_path (str): initial image, usually a check point image generated by the last training session.
            style_weights (:obj:`list` of :obj:`float`): an list of 5 numbers.
        """

        # The number of elements in `self.STYLE_LAYERS` must be the same as the number of elements in `style_weights`.
        # Note that deeper layers tend to extract more abstract features and the style weight for each layer determines
        # how much impact that layer will have on the style of generated image.
        self.STYLE_LAYERS = [
            ('conv1_1', style_weights[0]),
            ('conv2_1', style_weights[1]),
            ('conv3_1', style_weights[2]),
            ('conv4_1', style_weights[3]),
            ('conv5_1', style_weights[4])
        ]

        self._content_img = load_image(content_path, shape=[h, w], preprocess=True, bgr=False)
        self._style_img = load_image(style_path, shape=[h, w], preprocess=True, bgr=False)
        self._initial_image = None
        self._sess = tf.Session()
        
        # if the initial image is not sepcified, generate a new image and initialise it
        if input_image_path:
            self._initial_image = load_image(input_image_path, shape=[h, w], preprocess=True, bgr=False)
        else:
            self._initial_image = self._init_generated_image()

        self._vgg = Model('imagenet-vgg-verydeep-19.mat', img_h=h, img_w=w)
        self._out = self._vgg.build_model(output=output_layer)
        self._sess.run(tf.global_variables_initializer())           # Initialise variables to compute features
        self._content_features = self._compute_content_features()
        self._style_features = []

        self._compute_style_features()

    def run(self, num_iter=1000, output_folder="output", beta=1, alpha=2000, learning_rete=2.0):
        '''Run the computation graph and start generating images.

        Args
            num_iter (int): Number of iterations the optmiser will run.
            output_folder (str): Name of the folder to store generated images.
            beta (int): Content weight.
            alpha (int): Style weight.
            learning_rate (float): Learning rate used by the optimiser.
        '''

        content_loss = self._compute_content_loss(self._out)
        style_loss = self._compute_total_style_loss()
        total_loss = beta * content_loss + alpha * style_loss

        # L-BFGS-B generates better results than Adam 
        optimiser = tf.contrib.opt.ScipyOptimizerInterface(total_loss, method='L-BFGS-B', options={'maxiter': 10})
        self._sess.run(self._vgg.tf_layers['input'].assign(self._initial_image))

        for i in range(1, num_iter + 1):
            step = i * 10
            optimiser.minimize(self._sess)
            generated_img = self._sess.run(self._vgg.tf_layers['input'])        # Retrive the updated image from the input layer
            current_loss = self._sess.run(total_loss)
            print('Iter ' + str(step) + ' Loss: ' + str(current_loss))
            self._save_image(output_folder + "/" + str(step) + ".png", generated_img)
            if step >=  num_iter:
                break

        self._sess.close()

    def _gram_mat(self, M):
        """Compute the gram matrix of a given matrix.

        Args:
            M (:obj:`Tensor`): A 2D tensor.
        
        Returns:
            A tensor representing the gram matrix of the 2D tensor.
        """
        return tf.matmul(tf.transpose(M), M)

    def _save_image(self, path, image):
        """Save an image to a specific path.

        Args:
            path (str): Path to save the image to.
            image: A image stored in a numpy array.
        """

        MEAN = [123.68, 116.779, 103.939]       # add the vgg means back to de-precess the image
        image = image + MEAN
        image = np.clip(image[0], 0, 255).astype('uint8')
        scipy.misc.imsave(path, image)

    def _compute_layer_style_loss(self, ori_features, gen_features):
        """Computes the style loss of a layer.

        Args:
            ori_features(:obj:`Tensor`): The layer output of the original style image.
            gen_features(:obj:`Tensor`): The layer output of the generated image.

        Returns: 
            The style loss of the layer.
        """
        _, h, w, c = ori_features.shape
        # unroll before computing gram
        O = self._gram_mat(tf.reshape(ori_features, [h * w , c]))
        G = self._gram_mat(tf.reshape(gen_features, [h * w , c]))
        loss = (1./(4. * c**2 * (h * w) **2)) * tf.reduce_sum(tf.pow((G - O), 2))
        return loss

    def _compute_total_style_loss(self):
        """Computes the total style loss across all alyers.

        Returns: 
            A tensor.
        """
        loss = 0
        for i in range(len(self.STYLE_LAYERS)):
            ori_style_features = self._style_features[i]
            layer, coeff = self.STYLE_LAYERS[i]
            gen_style_features = self._vgg.tf_layers[layer]
            loss += coeff * self._compute_layer_style_loss(ori_style_features, gen_style_features)
        
        return loss

    def _compute_content_loss(self, generated_features):
        '''Computes the content loss

        Args:
            generated_features (:obj:`Tensor`): layer output of the generated image.

        Returns: 
            A tensor.
        '''
        _, h, w, c = self._content_features.shape
        loss = (1./ (2. * (h * w)**0.5 * c**0.5)) * tf.reduce_sum(tf.pow((generated_features - self._content_features), 2))
        return loss


    def _compute_content_features(self):
        """Computes the layer output of the content image in the output layer.

        Returns: 
            A numpy array containing content features computed.
        """
        op_assign_content_img = self._vgg.tf_layers['input'].assign(self._content_img)
        self._sess.run(op_assign_content_img)
        res = self._sess.run(self._out)
        return res
            
    def _compute_style_features(self):
        """Computes layer outputs for all layers in 'self.STYLE_LAYERS' and append the results to 'self._style_features'
        """
        op_assign_style_img = self._vgg.tf_layers['input'].assign(self._style_img)
        self._sess.run(op_assign_style_img)
        for layer, _ in self.STYLE_LAYERS:
            out = self._vgg.tf_layers[layer]
            self._style_features.append(self._sess.run(out))

    def _init_generated_image(self, noise_ratio=0.1):
        """Initialise a new image and return it.

        Instead of initialising the image with noise, we mix in the content image so the model takes less time to produce
        good results.

        Args:
            noise_ratio (float): ratio of content image vs noise image

        Returns:
            An image stored in a numpy array.
        """
        noise = np.random.uniform(
        self._content_img.mean() - self._content_img.std(), self._content_img.mean() + self._content_img.std(),
        (self._content_img.shape)).astype('float32')
        input_image = noise * noise_ratio + self._content_img * (1 - noise_ratio)
        return input_image


